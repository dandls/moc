% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Counterfactuals.R
\name{Counterfactuals}
\alias{Counterfactuals}
\title{Counterfactual Explanations}
\format{
\code{\link{R6Class}} object.
}
\description{
\code{Counterfactuals} are calculated based on the NSGA-II with mixed integer evolutionary strategies by Li et al. (2013).
The method is available in the package mosmafs, which is based on the package ecr.
}
\details{
Different initialization strategies for the candidates of the first population exist:
\describe{
\item{\code{random}}{randomly sample from numerical feature ranges and
discrete feature values of the given training data and randomly set some
feature values to the values of 'x.interest'.}
\item{\code{icecurve}}{Randomly sample the feature values of the initial
candidates as in the strategy 'random' but use the ice curve variance to
determine which feature values are the same as for \code{x.interest}.
A lower ICE curve variance of one feature results in a higher probability for keeping the
features values fixed to the value of \code{x.interest}.}
\item{\code{sd}}{Randomly sample numerical features from the feature ranges
that are limited by the standard deviation extracted from observed dataset. Discrete features
are sampled randomly as for the \code{random} strategy and some feature are randomly set to the
values of \code{x.interest}.}
\item{\code{traindata}}{Initialize the first population as the observed training data
points are best according to their ranks determined by nondominated sorting and crowding distance sorting.}
}
}
\section{Usage}{

\preformatted{
cf = Counterfactuals$new(predictor, x.interest = NULL, target = NULL,
epsilon = NULL, fixed.features = NULL, max.changed = NULL,
mu = 59, generations = 60, p.mut = 0.7, p.rec = 0.6, p.mut.gen = 0.25,
p.mut.use.orig = 0.2, p.rec.gen = 0.6, p.rec.use.orig = 0.7,
k = 1L, weights = NULL, lower = NULL, upper = NULL, initialization = "random",
track.infeas = TRUE)

plot(cf)
cf$results
cf$log
print(cf)
cf$explain(x.interest, target)
cf$subset_results(nr.solutions = 10)
cfs$continue_search(generations)
cf$plot_search()
cf$plot_parallel(features, row.ids)
cf$plot_surface(features, grid.size)
cf$plot_hv()
cf$plot_statistics()
cf$get_hv()
cf$get_frequency(plot = FALSE, subset.zero = FALSE)
}
}

\section{Arguments}{

For Counterfactuals$new()
\describe{
\item{predictor: }{(Predictor)\cr
The object (created with Predictor$new()) holding the machine learning model and the data.}
\item{x.interest: }{(data.frame)\cr  Single row with the instance to be explained.}
\item{target: }{(numeric(1)|numeric(2))\cr Desired outcome either a single numeric or
a vector of two numerics, to define a desired interval as outcome.}
\item{epsilon: }{(numeric(1))\cr Soft constraint. If chosen, candidates, whose
distance between their prediction and target exceeds epsilon, are penalized.
Default is NULL.}
\item{fixed.features: }{(character|numeric)\cr
Name or index of feature(s), which are not allowed to be changed.
Index refers to ordering of feature names of data used to initialize predictor.
Default is NULL.}
\item{max.changed: }{integer(1)\cr Maximum number of features that can be changed.
Default is NULL.}
\item{mu: }{(integer(1))\cr Population size.
Default is 59.}
\item{generations: }{(integer(1))\cr Number of generations. Default is 60.}
\item{p.mut: }{numeric(1)\cr Probability a child is chosen to be mutated.
Default is 0.7.}
\item{p.rec: }{numeric(1)\cr Probability a pair of parents is chosen to recombine.
Default is 0.6.}
\item{p.mut.gen:}{numeric(1)\cr Probability one feature/gene is mutated.
Default is 0.25.}
\item{p.mut.use.orig:}{numeric(1)\cr Probability an element of the indicator
to use the feature value of x.interest is mutated. As hamming weight
bitflip mutation is used, only a probability between 0 and 0.5 is allowed.
Default is 0.2.}
\item{p.rec.gen:}{numeric(1)\cr Probability one feature/gene is recombined.
Default is 0.6.}
\item{p.rec.use.orig:}{numeric(1)\cr Probability an elment of the indicator
to use the feature values of x.interest is recombined.
Default is 0.7.}
\item{lower:}{numeric\cr Vector of minimal values for numeric features. If NULL
(default) lower is extracted from input data specified in field 'data' of 'predictor'.}
\item{upper: }{numeric\cr Vector of maximal values for numeric features.
If NULL (default) upper is extracted from input data specified in field 'data' of
'predictor'.}
\item{initialization: }{character(1)\cr Which initialization strategy should
be used, either 'random', 'icecurve', 'sd' or 'traindata'. See details for an
overview and explanation. Default is 'random'.}
\item{track.infeas: }{logical(1)\cr Whether to add a fourth objective that
evaluates the minimum Gower distance to observed data set. How many
nearest neighbors are considered is specified in the k and how
the distance to each neighbors is weighted is specified in weights. Default is TRUE.}
\item{k: }{integer(1)\cr How many nearest neighbors should be considered
for the fourth objective. See track.infeas for details. It is only used if
track.infeas is TRUE. Default is 1L.}
\item{weights: }{numeric(1)|numeric(k)\cr How the k nearest neighhbors of the observed dataset
should be weighted. The first value corresponds to the nearest neighbor.
It is either a single value or a vector of length k. The values should sum up to 1.
See track.infeas for details. It is only used if
track.infeas is TRUE. Default is NULL which means all neighbors are weighted equally as 1/k.}
\item{nr.solutions: }{integer(1)\cr How many 'best' counterfactuals should be kept.
Ranking of the counterfactuals is done by nondominated sorting and crowding distance sorting.
Default 10L.}
\item{features: }{character\cr Which features should be plotted.}
\item{row.ids: }{numeric\cr Which counterfactuals (row number) should be plotted.}
\item{grid.size: }{integer\cr The size of the grid for evaluating the predictions. Default 50L.}
\item{plot: }{logical(1)\cr Whether frequencies of feature changes should be plotted.}
\item{subset.zero: }{logical(1)\cr Whether features with no proposed changes should be omited.}
}
}

\section{Methods}{

\describe{
\item{\code{clone()}}{[internal] Method to clone the R6 object.}
\item{\code{initialize()}}{[internal] Method to initialize the R6 object.}
\item{\code{subset_results(nr.solutions)}}{Returns a subset of Counterfactuals
as in Counterfactuals$results of the size of nr. solutions.}
\item{\code{explain(x.interest, target)}}{Method to set a new data point which to explain.}
\item{\code{plot()}}{Method to plot the Pareto front in 2-D. See \link{plot.Counterfactuals.}}
\item{\code{continue_search(generations)}}{Method to continue search
after run was already finished. Results are automatically updated in
Counterfactuals$results.}
\item{\code{get_hv()}}{Get dominated hypervolume of Counterfactual set
equal to fitness.dominatedHV of last row in cf$log.}
\item{\code{get_frequency()}}{Calculate frequency a feature got changed
over the returned set of Counterfactuals.}
\item{\code{plot_statistics()}}{Method to plot information of Counterfactuals$log
for evaluation of algorithm.}
\item{\code{plot_surface(features, row.ids)}}{Method to plot prediction surface given two features and
mark \code{x.interest} and its corresponding counterfactuals on the plot. If row.ids is NULL all
counterfactuals are plotted.}
\item{\code{plot_parallel(features, row.ids)}}{Method to plot a parallel plot of the feature changes.
If features is NULL all features are plotted and if row.ids is NULL all counterfactuals are plotted.}
}
}

\examples{
if (require("randomForest")) {
# First we fit a machine learning model on the Boston housing data
data("Boston", package  = "MASS")
rf =  randomForest(medv ~ ., data = Boston)
X = Boston[-which(names(Boston) == "medv")]
mod = Predictor$new(rf, data = X)

# Then we explain the prediction of the first instance with the
# Counterfactuals method
x.interest = X[1,]
target = 30
counterfactual = Counterfactuals$new(mod, x.interest = x.interest,
target = target, generations = 10)
counterfactual

# Look at the results in a table
counterfactual$results
# Or as a plot
plot(counterfactual)
plot(counterfactual, labels = TRUE, nr.solutions = 10)

# Explain another instance
counterfactual$explain(X[2,], target = target)
plot(counterfactual)

# Counterfactuals() can only focus on one class, not multiple
# classes at a time
rf = randomForest(Species ~ ., data = iris)
X = iris[-which(names(iris) == "Species")]
mod = Predictor$new(rf, data = X, type = "prob", class = "setosa")

# Then we explain the prediciton of the first instance
counterfactuals = Counterfactuals$new(mod, x.interest = X[1,], target = 0,
generations = 10)
counterfactuals$results
plot(counterfactuals)
}
}
\references{
\describe{
\item{Dandl, S., Molnar, C., Binder, M., Bischl, B. (2020). Multi-Objective Counterfactual Explanations. Preprint on ArXiv.}
\item{Li, R., Emmerich, M.T., Eggermont, J., Bäck, T., Schütz, M., Dijkstra, J., Reiber, J.H. (2013).
 Mixed Integer Evolution Strategies for Parameter Optimization. Evolutionary Computation 21(1): 29–64}
\item{Binder, M., Moosbauer, J., Thomas, J., Bischl, B. (2019).
Multi-Objective Hyperparameter Tuning and Feature Selection using Filter Ensembles (2019), accepted at GECCO 2020}
\item{Bossek, J. (2017). ecr 2.0: A modular framework for evolutionary computation in r,
Proceedings of the Genetic and Evolutionary Computation Conference Companion,
GECCO '17, pp. 1187-1193.}{}
\item{Deb, K., Pratap, A., Agarwal, S. and Meyarivan, T. (2002). A fast and elitist multiobjective
genetic algorithm: Nsga-ii, IEEE Transactions on Evolutionary Computation
6(2): 182-197.}{}
\item{Avila, S. L.,  Kraehenbuehl, L. and Sareni, B. (2006). A multi-niching
multi-objective genetic algorithm for solving complex multimodal problems,
OIPE, Sorrento, Italy.}{}
}
}
\seealso{
A different way to explain predictions: \link{LocalModel}, \link{Shapley}
}
